## 1

Ответ на первое задание:
1. Есть возможность что get-параметр id не будет прислан, нужно проверку на это сделать.
2. Вместо конкатенации ID к запросу, нужно использовать именованные параметры (биндить их). В ином случае спокойно можно применить SQL-инъекцию.

Если злоумышленник отправит в id строку " AND WHERE 1 = 1", то будет получение всех пользователей. Это еще простой случай, подставляя ";" в конце, можно и другие запросы выполнять.

Пример:
```
SELECT * FROM users WHERE u_id = 1; DELETE FROM users 
```
и т.д

Исправленная версия в 1.php

---

## 2

Ответ на второе задание находится во 2.php

---

## 3 

Ответ на третье задание:
```
SELECT
    name,
    phone,
    SUM(subtotal) as sum_all_orders,
    AVG(subtotal) as average_check,
    MAX(o.created) as last_order_date
FROM `users` as u 
JOIN `orders` as o ON u.id = o.user_id
GROUP BY o.user_id
```

Проблем с only_full_group_by не будет, так как у нас используется агрегирующие функции

---

## 4

Ответ на четвертое задание:

Первый запрос: `SELECT MAX(salary) FROM employees GROUP BY departament_id`.

Второй запрос: `SELECT * FROM employees WHERE departament_id = 3 AND salary > 90000`

Третий запрос: 

Тут задача довольно мутная, цель не понял, проверка ли это на то, знаю ли я синтаксис или проверка на то, как я это вычислю.

До создания индекса, сперва нужно немного аналитику собрать. Нужно включить slow log, отследить медленные запросы и ставить на них индексы.

В случае если у нас составные индексы, то вычисляем их селективность и в индекс подставляем колонку с наибольшей селективностью.

Но так как я не знаю содержимое таблицы, то я предположу что частый поиск будет идти по депортаментам и создам индекс на него.

`CREATE INDEX employees_departament_id ON employees (departament_id)`

Также можно создать на зарплату.

---

# 5

Ответ на пятое задание находится в файле 5.js


---

Потратил где-то час. Мог бы закончить где-то за 25 минут, но хотел подробно расписать

    
    
